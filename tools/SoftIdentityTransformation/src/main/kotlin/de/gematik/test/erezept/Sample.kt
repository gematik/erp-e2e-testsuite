/*
 * Copyright 2023 gematik GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.gematik.test.erezept

import de.gematik.test.erezept.crypto.certificate.X509CertificateWrapper
import java.io.ByteArrayInputStream
import java.security.cert.CertificateFactory
import java.security.cert.X509Certificate


fun main(args: Array<String>) {
  val input =
    "308204FC308203E4A00302010202030F4499300D06092A864886F70D01010B05003081AB310B300906035504061302444531333031060355040A0C2A41746F7320496E666F726D6174696F6E20546563686E6F6C6F677920476D6248204E4F542D56414C494431453043060355040B0C3C456C656B74726F6E697363686520476573756E6468656974736B617274652D4341206465722054656C656D6174696B696E667261737472756B7475723120301E06035504030C1741544F532E45474B2D4341323520544553542D4F4E4C59301E170D3233303230373133343532375A170D3238303230373133343532375A30819B310B3009060355040613024445311F301D060355040A0C16546563686E696B6572204B72616E6B656E6B6173736531123010060355040B0C0931303135373535313931133011060355040B0C0A543032323533333133353113301106035504040C0A4D75737465726D616E6E3110300E060355042A0C074A756C69616E65311B301906035504030C124A756C69616E65204D75737465726D616E6E30820122300D06092A864886F70D01010105000382010F003082010A0282010100929416AE1138C3B9E5D6A8A441BFDFEAA0484AFE28D27DF57388B3A8A9C2EEA50740017445949867CFDA0AB9FD32D4E3E836D15F749F083332DD819B32B17578226455787265A4651D569BFA3DEA452FDB456DE7F71E6CB25079D4AEC2FCC1D594B8C3A6876DCC6DE4187A77697AF1B2B5C9AE499010A026A8795E796236B08491A8FE0DB51A01AF8095B2790F952CFF98B87B5729AD4201C75DDDEB3878A074AC3AA0EA71E0C40F46FC31304B4A9B593A33CF3A6C2E04475C82447DF728F206BB375F32644C853FB2926CB0BE5CFD1FAFABC891BB44B50920A060B57F1C7594FEB705621ECB769B0EB54A787C9391AAEC6204B6617085D5A07A5AFD7E22B53D0203010001A382013530820131301D0603551D0E0416041407FBB0BF569A74A667CDAE1D0C5CF1E7C3DD86D9300E0603551D0F0101FF040403020780300C0603551D130101FF0402300030510603551D20044A3048300906072A8214004C0446303B06082A8214004C048123302F302D06082B060105050702011621687474703A2F2F7777772E67656D6174696B2E64652F676F2F706F6C6963696573303706082B06010505070101042B3029302706082B06010505073001861B687474703A2F2F6F6373702E65676B2D746573742D7473702E6465301F0603551D2304183016801423BF87A85E734AC087658188054CE4D89B14D58E30130603551D25040C300A06082B06010505070302303006052B240803030427302530233021301F301D30100C0E56657273696368657274652F2D72300906072A8214004C0431300D06092A864886F70D01010B050003820101000691F12D18A40932A10E54429072854AE7480B216DCD54590F6CF6BA9D6A689DBBC4EB50A868B4247F74D00D38D0CD584C74EDFD618A0D134B0A6FB80E28C2F22A25FD39A5D08345F0329C3F8D172C998718EA40EDFCF0E68D2CE48702CED7A807E2670961AAA45C0AE1B41EB022748779EC29A7D48727ED19FF120CBE2EC51FD1C214B3B5281AA64CC375857022CCDAE484873AED5353001CCD8C1780E61B1B149440EF2997020E4C0FF9E8E71DE26C7D4CE5C67C5A367CF5575AAAE677F2C51CC7203F691C8EAEB28023463DE781C10E11F4A050AD96114683BFA30030E28E74547F94FE003891D478746CC67410D9CEF5527C0A0E4188B6D273250A93CEF2".decodeHex()
  val certFactory: CertificateFactory = CertificateFactory.getInstance("X.509")
  val cert: X509Certificate =
    certFactory.generateCertificate(ByteArrayInputStream(input)) as X509Certificate
  val cert1 = X509CertificateWrapper(cert)
  println()
}

private fun String.decodeHex(): ByteArray {
  check(length % 2 == 0) { "Must have an even length" }

  return chunked(2)
    .map { it.toInt(16).toByte() }
    .toByteArray()
}